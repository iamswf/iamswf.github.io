---
layout: post
title:  "JavaScript函数式编程"
date:   2016-11-16
summary: "本篇文章主要介绍容器，半群，monoid等范畴学概念在JavaScript中的实现。"
category: javascript
---

## JavaScript函数式编程

### 1. 使用容器（`Box`）创建线性数据流

普通函数是这样的：

```javascript
function nextCharForNumberString (str) {
  const trimmed = str.trim();
  const number = parseInt(trimmed);
  const nextNumber = number + 1;
  return String.fromCharCode(nextNumber);
}

const result = nextCharForNumberString(' 64');
console.log(result); // "A"
```

如果借助Array，可以这样实现：

```javascript
const nextCharForNumberString = str =>
    [str]
    .map(s => s.trim())
    .map(s => parseInt(s))
    .map(i => i + 1)
    .map(i => String.fromCharCode(i));

const result = nextCharForNumberString(' 64');
console.log(result); // ["A"]
```

这里我们把数据`str`装进了一个箱子（数组），然后连续多次调用箱子的`map`方法来处理箱子内部的数据。这种实现已经可以感受到一些奇妙之处了。再看一种基本思想相同的实现方式，只不过这次我们不借助数组，而是自己实现箱子：

```javascript
const Box = x => ({
  map: f => Box(f(x)),
  fold: f => f(x),
  toString: () => `Box(${x})`
});

const nextCharForNumberString = str =>
    Box(str)
    .map(s => s.trim())
    .map(s => parseInt(s))
    .map(i => i + 1)
    .map(i => String.fromCharCode(i));

const result = nextCharForNumberString(' 64');
console.log(String(result)); // "Box(A)"
```

至此我们自己动手实现了一个箱子。这里的`map`需要特别注意，并不是用来循环一组数据，而是用来组合一组操作，以创建线性的数据流。

### 2. 使用`Box`重构命令式代码

这里使用的`Box`跟上一节一样：

```javascript
const Box = x => ({
  map: f => Box(f(x)),
  fold: f => f(x),
  toString: () => `Box(${x})`
});
```



命令式`moneyToFloat`：

```javascript
const moneyToFloat = str =>
    parseFloat(str.replace(/\$/g, ''));
```

`Box`式`moneyToFloat`：

```javascript
const moneyToFloat = str =>
    Box(str)
    .map(s => s.replace(/\$/g, ''))
    .fold(r => parseFloat(r));
```

我们这里使用`Box`重构了`moneyToFloat`，`Box`擅长的地方就在于将嵌套表达式转成一个一个的`map`，这里虽然不是很复杂，但却是一种好的实践方式。



命令式`percentToFloat`：

```javascript
const percentToFloat = str => {
  const replaced = str.replace(/\%/g, '');
  const number = parseFloat(replaced);
  return number * 0.01;
};
```

`Box`式`percentToFloat`：

```javascript
const percentToFloat = str =>
    Box(str)
    .map(str => str.replace(/\%/g, ''))
    .map(replaced => parseFloat(replaced))
    .fold(number => number * 0.01);
```

我们这里又使用`Box`重构了`percentToFloat`，显然这种实现方式的数据流更加清晰。



命令式`applyDiscount`：

```javascript
const applyDiscount = (price, discount) => {
  const cost = moneyToFloat(price);
  const savings = percentToFloat(discount);
  return cost - cost * savings;
};
```

重构`applyDiscount`稍微麻烦点，因为该函数有两条数据流，不过我们可以借助闭包：

`Box`式`applyDiscount`：

```javascript
const applyDiscount = (price, discount) =>
    Box(price)
    .map(price => moneyToFloat(price))
    .fold(cost =>
        Box(discount)
        .map(discount => percentToFloat(discount))
        .fold(savings => cost - cost * savings));
```

现在可以看一下这组代码的输出了：

```javascript
const result = applyDiscount('$5.00', '20%');

console.log(String(result)); // "4"
```



如果我们在`moneyToFloat`和`percentToFloat`中不进行拆箱（即`fold`），那么`applyDiscount`就没必要在数据转换之前先装箱（即`Box`）了：

```javascript
const moneyToFloat = str =>
    Box(str)
    .map(s => s.replace(/\$/g, ''))
    .map(r => parseFloat(r)); // here we don't fold the result out

const percentToFloat = str =>
    Box(str)
    .map(str => str.replace(/\%/g, ''))
    .map(replaced => parseFloat(replaced))
    .map(number => number * 0.01); // here we don't fold the result out

const applyDiscount = (price, discount) =>
    moneyToFloat(price)
    .fold(cost =>
        percentToFloat(discount)
        .fold(savings => cost - cost * savings));

const result = applyDiscount('$5.00', '20%');

console.log(String(result)); // "4"
```

### 3. 使用`Either`进行分支控制

`Either`的意思是两者之一，不是`Right`就是`Left`。我们先实现`Right`：

```javascript
const Right = x => ({
  map: f => Right(f(x)),
  toString: () => `Right(${x})`
});

const result = Right(3).map(x => x + 1).map(x => x / 2);
console.log(String(result)); // "Right(2)"
```

这里我们暂且不实现`Right`的`fold`，而是先来实现`Left`：

```javascript
const Left = x => ({
  map: f => Left(x),
  toString: () => `Left(${x})`
});

const result = Left(3).map(x => x + 1).map(x => x / 2);
console.log(String(result)); // "Left(3)"
```

`Left`容器跟`Right`是不同的，因为`Left`完全忽略了传入的数据转换函数，保持容器内部数据原样。有了`Right`和`Left`，我们可以对程序数据流进行分支控制。考虑到程序中经常会存在异常，因此容器通常都是未知类型`RightOrLeft`。

接下来我们实现`Right`和`Left`容器的`fold`方法，如果未知容器是`Right`，则使用第二个函数参数`g`进行拆箱：

```javascript
const Right = x => ({
  map: f => Right(f(x)),
  fold: (f, g) => g(x),
  toString: () => `Right(${x})`
});
```

如果未知容器是`Left`，则使用第一个函数参数`f`进行拆箱：

```javascript
const Left = x => ({
  map: f => Left(x),
  fold: (f, g) => f(x),
  toString: () => `Left(${x})`
});
```

测试一下`Right`和`Left`的`fold`方法：

```javascript
const result = Right(2).map(x => x + 1).map(x => x / 2).fold(x => 'error', x => x);
console.log(result); // 1.5
```

```javascript
const result = Left(2).map(x => x + 1).map(x => x / 2).fold(x => 'error', x => x);
console.log(result); // 2
```

借助`Either`我们可以进行程序流程分支控制，例如进行异常处理、`null`检查等。

下面看一个例子：

```javascript
const findColor = name =>
    ({red: '#ff4444', blue: '#3b5998', yellow: '#fff68f'})[name];

const result = findColor('red').slice(1).toUpperCase();
console.log(result); // "FF4444"
```

这里如果我们给函数`findColor`传入`green`，则会报错。因此可以借助`Either`进行错误处理：

```javascript
const findColor = name => {
  const found = {red: '#ff4444', blue: '#3b5998', yellow: '#fff68f'}[name];
  return found ? Right(found) : Left(null);
};

const result = findColor('green')
            .map(c => c.slice(1))
            .fold(e => 'no color',
                 c => c.toUpperCase());
console.log(result); // "no color"
```

更进一步，我们可以提炼出一个专门用于`null`检测的`Either`容器，同时简化`findColor`代码：

```javascript
const fromNullable = x =>
    x != null ? Right(x) : Left(null); // [!=] will test both null and undefined

const findColor = name =>
    fromNullable({red: '#ff4444', blue: '#3b5998', yellow: '#fff68f'}[name]);
```

### 4. 利用`chain`解决`Either`的嵌套问题

看一个读取配置文件`config.json`的例子，如果位置文件读取失败则提供一个默认端口`3000`，命令式代码实现如下：

```javascript
const fs = require('fs');

const getPort = () => {
  try {
    const str = fs.readFileSync('config.json');
    const config = JSON.parse(str);
    return config.port;
  } catch (e) {
    return 3000;
  }
};

const result = getPort();
console.log(result); // 8888 or 3000
```

我们使用`Either`重构：

```javascript
const fs = require('fs');

const tryCatch = f => {
  try {
    return Right(f());
  } catch (e) {
    return Left(e);
  }
};

const getPort = () =>
    tryCatch(() => fs.readFileSync('config.json'))
    .map(c => JSON.parse(c))
    .fold(
        e => 3000,
        obj => obj.port
    );

const result = getPort();
console.log(result); // 8888 or 3000
```

重构后就完美了吗？我们用到了`JSON.parse`，如果`config.json`文件格式有问题，程序就会报错：

> SyntaxError: Unexpected end of JSON input

因此需要针对`JSON`解析失败做异常处理，我们可以继续使用`tryCatch`来解决这个问题：

```javascript
const getPort = () =>
    tryCatch(() => fs.readFileSync('config.json'))
    .map(c => tryCatch(() => JSON.parse(c)))
    .fold(
        left => 3000, // 第一个tryCatch失败
        right => right.fold( // 第一个tryCatch成功
            e => 3000, // JSON.parse失败
            c => c.port
        )
    );
```

这次重构我们使用了两次`tryCatch`，因此导致箱子套了两层，最后需要进行两次拆箱。为了解决这种箱子套箱子的问题，我们可以给`Right`和`Left`增加一个方法`chain`：

```javascript
const Right = x => ({
  chain: f => f(x),
  map: f => Right(f(x)),
  fold: (f, g) => g(x),
  toString: () => `Right(${x})`
});

const Left = x => ({
  chain: f => Left(x),
  map: f => Left(x),
  fold: (f, g) => f(x),
  toString: () => `Left(${x})`
});
```

当我们使用`map`，又不想在数据转换之后又增加一层箱子时，我们应该使用`chain`：

```javascript
const getPort = () =>
    tryCatch(() => fs.readFileSync('config.json'))
    .chain(c => tryCatch(() => JSON.parse(c)))
    .fold(
        e => 3000,
        c => c.port
    );
```

### 5. 命令式代码使用`Either`实现举例

```javascript
const openSite = () => {
  if (current_user) {
      return renderPage(current_user);
    }
    else {
      return showLogin();
    }
};

const openSite = () =>
    fromNullable(current_user)
    .fold(showLogin, renderPage);
```

```javascript
const streetName = user => {
  const address = user.address;
  if (address) {
    const street = address.street;
    if (street) {
      return street.name;
    }
  }
  return 'no street';
};

const streetName = user =>
    fromNullable(user.address)
    .chain(a => fromNullable(a.street))
    .map(s => s.name)
    .fold(
        e => 'no street',
        n => n
    );
```

```javascript
const concatUniq = (x, ys) => {
  const found = ys.filter(y => y ===x)[0];
  return found ? ys : ys.concat(x);
};

const cancatUniq = (x, ys) =>
    fromNullable(ys.filter(y => y ===x)[0])
    .fold(null => ys.concat(x), y => ys);
```

```javascript
const wrapExamples = example => {
  if (example.previewPath) {
    try {
      example.preview = fs.readFileSync(example.previewPath);
    }
    catch (e) {}
  }
  return example;
};

const wrapExamples = example =>
    fromNullable(example.previewPath)
    .chain(path => tryCatch(() => fs.readFileSync(path)))
    .fold(
        () => example,
        preivew => Object.assign({preview}, example)
    );
```

### 6. 半群

半群是一种具有`concat`方法的类型，并且该`concat`方法满足结合律。比如`Array`和`String`：

```javascript
const res = "a".concat("b").concat("c");
const res = [1, 2].concat([3, 4].concat([5, 6])); // law of association
```

我们自定义`Sum`半群，`Sum`类型用来求和：

```javascript
const Sum = x => ({
  x,
  concat: o => Sum(x + o.x),
  toString: () => `Sum(${x})`
});

const res = Sum(1).concat(Sum(2));
console.log(String(res)); // "Sum(3)"
```

继续自定义`All`半群，`All`类型用来级联布尔类型：

```javascript
const All = x => ({
  x,
  concat: o => All(x && o.x),
  toString: () => `All(${x})`
});

const res = All(true).concat(All(false));
console.log(String(res)); // "All(false)"
```

继续定义`First`半群，`First`类型链式调用`concat`方法不改变其初始值：

```javascript
const First = x => ({
  x,
  concat: o => First(x),
  toString: () => `First(${x})`
});

const res = First('blah').concat(First('ice cream'));
console.log(String(res)); // "First(blah)"
```

### 7. 半群举例

这里先占位，回头再补充。

```javascript
const acct1 = Map({
  name: First('Nico'),
  isPaid: All(true),
  points: Sum(10),
  friends: ['Franklin']
});

const acct2 = Map({
  name: First('Nico'),
  isPaid: All(false),
  points: Sum(2),
  friends: ['Gatsby']
});

const res = acct1.concat(acct2);
console.log(res);
```

### 8. monoid

半群满足结合律，如果半群还具有幺元（单位元），那么就是monoid。幺元与其他元素结合时不会改变那些元素，可以用公式表示如下：

> e・a = a・e = a

我们将半群`Sum`升级实现为monoid只需实现一个`empty`方法，调用改方法即可得到该monoid的幺元：

```javascript
const Sum = x => ({
  x,
  concat: o => Sum(x + o.x),
  toString: () => `Sum(${x})`
});

Sum.empty = () => Sum(0);

const res = Sum.empty().concat(Sum(1).concat(Sum(2)));
// const res = Sum(1).concat(Sum(2)).concat(Sum.empty());
console.log(String(res)); // "Sum(3)"
```

接着我们继续将`All`升级实现为monoid：

```javascript
const All = x => ({
  x,
  concat: o => All(x && o.x),
  toString: () => `All(${x})`
});

All.empty = () => All(true);

const res = All(true).concat(All(true)).concat(All.empty());
console.log(String(res)); // "All(true)"
```

如果我们尝试着将半群`First`也升级为monoid就会发现不可行，比如`First('hello').concat(…)`的结果恒为`hello`，但是`First.empty().concat(First('hello'))`的结果就不一定是`hello`了，因此我们无法将半群`First`升级为monoid。这也说明monoid一定是半群，但是半群不一定是monoid。半群需要满足结合律，monoid不仅需要满足结合律，还必须存在幺元。

### 9. monoid举例

